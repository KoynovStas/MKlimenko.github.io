---
layout: post

title: Программа для отображения цифровых сигналов
image: /assets/img/digital_signal_visualization/sine.png
lang: ru
categories: [russian]
tags: [GNSS, C++]
---

Мы живём в цифровую эру. Даже если вы не имеете понятия, в чём разница между процессором и оперативном памятью, GSM и GPS, вам всё равно нужно смириться с тем, что подавляющая часть окружающих вещей содержит в себе что-то цифровое. Это может быть простая RFID-метка на пакете молока или в билете на общественный транспорт, либо же сложное устройство, упакованное в красивый корпус.

Всё замечательно с точки зрения потребителя, поскольку устройства становятся умнее, меньше и дешевле. Одновременно с развитием технологий появляются и новые идеи, упрощая нашу ежедневную жизнь. Мы, инженеры, превращаем эти идеи в реальные устройства.

Когда речь идёт о реальных устройствах, сразу возникает потребность в работе с реальными сигналами, которые нужно посмотреть, проанализировать, сравнить, и.т.д. Для этих целей созданы несколько библиотек (например, gnuplot), но мне они кажутся слишком сложными и перегруженными функционалом. На моем месте работы у нас есть библиотека для внутреннего пользования, позволяющая строить одномерные сигналы и это восхитительная вещь. Она делает ровно то, что от неё требуется и даже чуть больше. Она прекрасно служит единственной цели: построить сигнал.

Однажды на собеседовании меня спросили, был ли у меня опыт и умею ли я читать и анализировать сигнал в двоичном виде, и этот вопрос меня очень сильно удивил, потому что кому захочется это делать "на пальцах", когда гораздо проще построить сигнал и посмотреть на него?

Вот почему я решил написать приложение, построенное на библиотеке, которую я упоминал ранее. Приложение тоже не перегружено функционалом и делает ровно одну вещь: отображает с указанными параметрами файл, который был ей передан. Например, вот результат передачи двух файлов с разной структурой (сверху комплексный 16-битовый сигнал, снизу действительный 8-битовый) в программу:

![Digital signal](/assets/img/digital_signal_visualization/sine.png)

Необходимое приведение типов тут реализовано достаточно просто, программа читает файл в виде массива байт (uint8_t, если быть точнее), а затем указатель на этот массив передаётся в библиотеку через reinterpret_cast.

Есть у программы и одна нерешенная проблема, а именно работа с упакованными сигналами. Сигналам ГНСС требуется всего 1-2 бита для эффективного квантования, так зачем тратить целый байт на каждый отсчёт? Несколько раз я видел оцифровки сигналов, которые были упакованы насколько это позволяет логика. Это сигнал с приёмника GPS/ГЛОНАСС диапазонов L1 и L2, в котором каждый байт выглядел следующим образом (если делить на биты): 

| | | | | | | | |
|:--|:--|:--|:--|:--|:--|:--|:--|
|GPS L1 Inphase|GPS L1 Quadrature|GLN L1 Inphase|GLN L1 Quadrature|GPS L2 Inphase|GPS L2 Quadrature|GLN L2 Inphase|GLN L2 Quadrature|

На данный момент я не могу придумать способ, как пользователю лучше сообщить способ упаковки сигнала программе. У меня есть пара идей, но они достаточно сложные и запутанные для конечного пользователя и я не хочу их использовать. Так что на данный момент перед отображением сигнала его нужно распаковать.

В любом случае, если вы как-то дочитали до этого места, то вы либо заинтересованы в этой программе, либо один из моих друзей, которым я наскучил ссылками на этот блог. Я не уверен, имею ли я право выкладывать прямую ссылку на программу, но если вы собираетесь её использовать в каком-нибудь некоммерческом проекте, смело пишите мне на электронную почту, которую можете найти в правом столбце этого блога.
