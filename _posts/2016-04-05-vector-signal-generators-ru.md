---
layout: post
title: Векторные генераторы сигналов
image: /assets/img/vector_signal_generator/n5182.jpg
lang: ru
categories: [russian]
tags: [GNSS, C++]
comments: true
---

Если вкратце, то современные СВЧ-устройства восхитительны. В особенности если обучение прошло на старых ламповых советских генераторах, частотомерах (привет метрологии) и осциллографах. Количество возможностей просто поражает.

![Keysight N5182A](/assets/img/vector_signal_generator/n5182.jpg)

Например, вот некоторые из качеств, которые радуют при работе:

1. Отменная стабильность в работе. 
2. Возможность удалённого управления. Это может быть как какой-то заготовленный сценарий, так и единичная настройка с последующей работой с этим сигналом.
3. Как продолжение предыдущего пункта: подобные устройства могут быть использованы для создания стендов для автоматизированного тестирования. Чтобы объяснить, что именно я имею в виду, необходимо пояснить цикл разработки нового оборудования.

Предположим, что у нас есть отличная аппаратно-программная платформа, в которой нет багов (что не всегда верно). Например, какая-нибудь SoC или ASIC. И мы хотим реализовать на ней новый алгоритм. Сначала разработчик должен провести теоретические исследования и создать правдоподобную модель. Модели просто отлаживать и они являются хорошим способом оценить производительность и качественные характеристики. Затем модель шаг за шагом модифицируется для максимального приближения или даже симуляции аппаратной платформы.

Когда эта стадия пройдена, самое время портировать алгоритм непосредственно на аппаратную платформу. И для тестирования необходимо создать подходящее окружение, т.е. серию тестов, каждый из которых требует собственного внешнего сигнала с генератора. Возможность удалённого управления позволяет создать тестовый сценарий (скрипт на Python, если вам это угодно, либо же программу на C++ с расписанной временной шкалой), запустить его на сбор информации (мы знаем внешнее воздействие и каков должен быть отклик на него. При совпадении ожиданий и действительности считается, что тест пройден), а сами идём играть в пинг-понг, пить кофе, либо же писать статью в блог о том, как здорово нынче быть инженером.

Сегодня я нашёл единственный недостаток в генераторе, с которым я работаю: невозможно запустить сигнал один раз без использования внешних триггеров. Сигнал может либо крутиться бесконечно много раз, либо запускаться по внешнему TTL-триггеру. Вопрос в том, как получить сигнал, который может являться триггером для генератора (желательно из Visual Studio)? Два часа поисков и тестирования различных вариантов из нашей коробки с хламом с применением WinAPI и мультиметра дало решение: USB-TTL программатор! Он стоит копейки (по сравнению со стоимостью аппаратной платформы и средств отладки), он нативно интегрируется в операционную систему как виртуальный COM-порт, а также показывает отличные результаты как триггер для генератора.

![USB TTL](/assets/img/vector_signal_generator/usb_ttl.jpg)

Конечно любое дополнительное оборудование это плохо. Есть ещё несколько подходов, которые я попробовал, но они либо не так хорошо работают, либо слишком сложны в исполнении.

Одним из самых очевидных решений является запустить генератор, подождать, пока сигнал закончится (время находится исходя из известного количества отсчётов и частоты дискретизации), после чего выключить генератор квадратурной модуляции. Это можно сделать, например, следующим образом:

```cpp
std::this_thred::sleep_for(std::chrono::microseconds(N))  
```

```std::chrono``` это отличный и достаточно точный инструмент, но с этим методом начинаются проблемы, когда мы имеем дело с короткими и высокочастотными сигналами (до 1 мс). Дело в том, что TCP/IP слишком медленный для таких сигналов и не сможет остановить генератор в нужное время. Есть вариант заполнить массив модуляции нулями после полезного сигнала, но это потребует огромного количества нулей и крайне неэффективно в плане потребления памяти. Но, если честно, я бы выбрал именно это решение, если бы не нашёл вариант с USB-TTL программатором.

Ещё есть способ, при котором генерируются две равные секции (сигнал и нули) с последующей загрузкой их обеих в генератор. После чего записывается сценарий, при котором секции переключаются по внешнему триггеру. Далее создаётся маркер (исходящий триггер) в конце секции сигнала и мы соединяем триггерные выход и вход генератора. Вуаля, происходит магия. Когда сигнал заканчивается, он запустит проигрывание секции нулей на повторе (до 65 тысяч раз). Здорово, не правда ли? Но слишком трудозатратно. Если TTL-программатор не справится со своей задачей, я пойду по этому пути.

UPD: Упс, вот что случается, когда слишком рано пишешь запись в блог. Нашёл способ контролировать одиночные триггеры при помощи SCPI (из своей библиотеки управления генератором). Репутация векторных генераторов восстановлена, а я посыпаю голову пеплом и иду дальше читать руководства.
